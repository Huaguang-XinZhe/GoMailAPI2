// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: proto/server.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MailService_GetLatestMail_FullMethodName      = "/MailService/GetLatestMail"
	MailService_FindMail_FullMethodName           = "/MailService/FindMail"
	MailService_GetJunkMail_FullMethodName        = "/MailService/GetJunkMail"
	MailService_SubscribeMail_FullMethodName      = "/MailService/SubscribeMail"
	MailService_RefreshToken_FullMethodName       = "/MailService/RefreshToken"
	MailService_BatchRefreshToken_FullMethodName  = "/MailService/BatchRefreshToken"
	MailService_DetectProtocolType_FullMethodName = "/MailService/DetectProtocolType"
)

// MailServiceClient is the client API for MailService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 邮件服务定义
type MailServiceClient interface {
	// 获取最新邮件
	GetLatestMail(ctx context.Context, in *GetNewMailRequest, opts ...grpc.CallOption) (*GetNewMailResponse, error)
	// 查找特定邮件
	FindMail(ctx context.Context, in *FindMailRequest, opts ...grpc.CallOption) (*FindMailResponse, error)
	// 获取垃圾邮件
	GetJunkMail(ctx context.Context, in *GetNewJunkMailRequest, opts ...grpc.CallOption) (*GetNewJunkMailResponse, error)
	// 邮件订阅流（SSE 替代方案）
	SubscribeMail(ctx context.Context, in *SubscribeMailRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MailEvent], error)
	// 刷新 Token
	RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
	// 批量刷新 Token
	BatchRefreshToken(ctx context.Context, in *BatchRefreshTokenRequest, opts ...grpc.CallOption) (*BatchRefreshTokenResponse, error)
	// 检测协议类型
	DetectProtocolType(ctx context.Context, in *DetectProtocolTypeRequest, opts ...grpc.CallOption) (*DetectProtocolTypeResponse, error)
}

type mailServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMailServiceClient(cc grpc.ClientConnInterface) MailServiceClient {
	return &mailServiceClient{cc}
}

func (c *mailServiceClient) GetLatestMail(ctx context.Context, in *GetNewMailRequest, opts ...grpc.CallOption) (*GetNewMailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNewMailResponse)
	err := c.cc.Invoke(ctx, MailService_GetLatestMail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailServiceClient) FindMail(ctx context.Context, in *FindMailRequest, opts ...grpc.CallOption) (*FindMailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindMailResponse)
	err := c.cc.Invoke(ctx, MailService_FindMail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailServiceClient) GetJunkMail(ctx context.Context, in *GetNewJunkMailRequest, opts ...grpc.CallOption) (*GetNewJunkMailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNewJunkMailResponse)
	err := c.cc.Invoke(ctx, MailService_GetJunkMail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailServiceClient) SubscribeMail(ctx context.Context, in *SubscribeMailRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MailEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MailService_ServiceDesc.Streams[0], MailService_SubscribeMail_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeMailRequest, MailEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MailService_SubscribeMailClient = grpc.ServerStreamingClient[MailEvent]

func (c *mailServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshTokenResponse)
	err := c.cc.Invoke(ctx, MailService_RefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailServiceClient) BatchRefreshToken(ctx context.Context, in *BatchRefreshTokenRequest, opts ...grpc.CallOption) (*BatchRefreshTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchRefreshTokenResponse)
	err := c.cc.Invoke(ctx, MailService_BatchRefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailServiceClient) DetectProtocolType(ctx context.Context, in *DetectProtocolTypeRequest, opts ...grpc.CallOption) (*DetectProtocolTypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DetectProtocolTypeResponse)
	err := c.cc.Invoke(ctx, MailService_DetectProtocolType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MailServiceServer is the server API for MailService service.
// All implementations must embed UnimplementedMailServiceServer
// for forward compatibility.
//
// 邮件服务定义
type MailServiceServer interface {
	// 获取最新邮件
	GetLatestMail(context.Context, *GetNewMailRequest) (*GetNewMailResponse, error)
	// 查找特定邮件
	FindMail(context.Context, *FindMailRequest) (*FindMailResponse, error)
	// 获取垃圾邮件
	GetJunkMail(context.Context, *GetNewJunkMailRequest) (*GetNewJunkMailResponse, error)
	// 邮件订阅流（SSE 替代方案）
	SubscribeMail(*SubscribeMailRequest, grpc.ServerStreamingServer[MailEvent]) error
	// 刷新 Token
	RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
	// 批量刷新 Token
	BatchRefreshToken(context.Context, *BatchRefreshTokenRequest) (*BatchRefreshTokenResponse, error)
	// 检测协议类型
	DetectProtocolType(context.Context, *DetectProtocolTypeRequest) (*DetectProtocolTypeResponse, error)
	mustEmbedUnimplementedMailServiceServer()
}

// UnimplementedMailServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMailServiceServer struct{}

func (UnimplementedMailServiceServer) GetLatestMail(context.Context, *GetNewMailRequest) (*GetNewMailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLatestMail not implemented")
}
func (UnimplementedMailServiceServer) FindMail(context.Context, *FindMailRequest) (*FindMailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindMail not implemented")
}
func (UnimplementedMailServiceServer) GetJunkMail(context.Context, *GetNewJunkMailRequest) (*GetNewJunkMailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJunkMail not implemented")
}
func (UnimplementedMailServiceServer) SubscribeMail(*SubscribeMailRequest, grpc.ServerStreamingServer[MailEvent]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeMail not implemented")
}
func (UnimplementedMailServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedMailServiceServer) BatchRefreshToken(context.Context, *BatchRefreshTokenRequest) (*BatchRefreshTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchRefreshToken not implemented")
}
func (UnimplementedMailServiceServer) DetectProtocolType(context.Context, *DetectProtocolTypeRequest) (*DetectProtocolTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetectProtocolType not implemented")
}
func (UnimplementedMailServiceServer) mustEmbedUnimplementedMailServiceServer() {}
func (UnimplementedMailServiceServer) testEmbeddedByValue()                     {}

// UnsafeMailServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MailServiceServer will
// result in compilation errors.
type UnsafeMailServiceServer interface {
	mustEmbedUnimplementedMailServiceServer()
}

func RegisterMailServiceServer(s grpc.ServiceRegistrar, srv MailServiceServer) {
	// If the following call pancis, it indicates UnimplementedMailServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MailService_ServiceDesc, srv)
}

func _MailService_GetLatestMail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNewMailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServiceServer).GetLatestMail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailService_GetLatestMail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServiceServer).GetLatestMail(ctx, req.(*GetNewMailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailService_FindMail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindMailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServiceServer).FindMail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailService_FindMail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServiceServer).FindMail(ctx, req.(*FindMailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailService_GetJunkMail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNewJunkMailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServiceServer).GetJunkMail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailService_GetJunkMail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServiceServer).GetJunkMail(ctx, req.(*GetNewJunkMailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailService_SubscribeMail_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeMailRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MailServiceServer).SubscribeMail(m, &grpc.GenericServerStream[SubscribeMailRequest, MailEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MailService_SubscribeMailServer = grpc.ServerStreamingServer[MailEvent]

func _MailService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServiceServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailService_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailService_BatchRefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchRefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServiceServer).BatchRefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailService_BatchRefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServiceServer).BatchRefreshToken(ctx, req.(*BatchRefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailService_DetectProtocolType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectProtocolTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServiceServer).DetectProtocolType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailService_DetectProtocolType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServiceServer).DetectProtocolType(ctx, req.(*DetectProtocolTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MailService_ServiceDesc is the grpc.ServiceDesc for MailService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MailService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "MailService",
	HandlerType: (*MailServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLatestMail",
			Handler:    _MailService_GetLatestMail_Handler,
		},
		{
			MethodName: "FindMail",
			Handler:    _MailService_FindMail_Handler,
		},
		{
			MethodName: "GetJunkMail",
			Handler:    _MailService_GetJunkMail_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _MailService_RefreshToken_Handler,
		},
		{
			MethodName: "BatchRefreshToken",
			Handler:    _MailService_BatchRefreshToken_Handler,
		},
		{
			MethodName: "DetectProtocolType",
			Handler:    _MailService_DetectProtocolType_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeMail",
			Handler:       _MailService_SubscribeMail_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/server.proto",
}
